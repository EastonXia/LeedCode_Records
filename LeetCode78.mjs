/**
  LeetCode78---子集
  
  给你一个整数数组 nums ，数组中的元素 互不相同 。返回该数组所有可能的子集（幂集）。
  解集 不能 包含重复的子集。你可以按 任意顺序 返回解集。

  示例 1：
  输入：nums = [1,2,3]
  输出：[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]
  
  示例 2：
  输入：nums = [0]
  输出：[[],[0]]
   
  提示：
    1 <= nums.length <= 10
    -10 <= nums[i] <= 10
    nums 中的所有元素 互不相同

*/

/**
 * @param {number[]} nums
 * @return {number[][]}
 *
 * 回溯法 (子集、组合类型) (这题leetCode官网的题解写得很好，有空去复习)
 * 回溯算法与 DFS 的区别就是有无状态重置
 * 当问题需要 "回头"，以此来查找出所有的解的时候，使用回溯算法。
 * 即满足结束条件或者发现不是正确路径的时候(走不通)，要撤销选择，回退到上一个状态，继续尝试，直到找出所有解为止
 * 
 * 怎么样写回溯算法(从上而下，※代表难点，根据题目而变化)
    ①画出递归树，找到状态变量(回溯函数的参数)，这一步非常重要※
    ②根据题意，确立结束条件
    ③找准选择列表(与函数参数相关),与第一步紧密关联※
    ④判断是否需要剪枝
    ⑤作出选择，递归调用，进入下一层
    ⑥撤销选择
 */
var subsets = function (nums) {
  var res = []; // 结果数据
  var path = []; // 路径数据

  dfs(nums, res, path, 0);

  return res;
};

/**
 * @param nums  输入的数据
 * @param res   结果数据
 * @param path  路径数据
 * @param start 选择的列表(路径)的起点
 * 
 * dfs入参定义
 * 固定变量 --- 此处是 nums、res
 * 状态变量 --- 此处是 path、start
 * 
 * 一般都会是循环与递归结合
 */
var dfs = function (nums, res, path, start) {
  res.push([...path]); // 这里一般是确定递归结束条件，此题所有路径都应该加入结果集，所以不存在结束条件，注意了要新建一个数据添加进去

  for (var i = start; i < nums.length; i++) {
    // 判断是否需要剪枝，这里不需要判断

    // 然后进行选择，先选择，后撤销选择
    path.push(nums[i]); // 做出选择
    dfs(nums, res, path, i + 1); // 进入下一层

    // 递归结束后撤销选择，回到上一层，进行状态重置，start会自动变回上一层的值，不需要任何操作
    // 路径数组也要到回到这一层的状态，因此要数组删除最后一个元素
    path.pop();
  }
};

function main() {
  console.log(subsets([1, 2, 3]));
  console.log(subsets([0]));
}

main();
